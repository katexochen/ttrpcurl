// Code generated by protoc-gen-go-ttrpc. DO NOT EDIT.
// source: test.proto
package grpctest

import (
	context "context"
	ttrpc "github.com/containerd/ttrpc"
)

type TestServiceService interface {
	EmptyCall(context.Context, *Empty) (*Empty, error)
	UnaryCall(context.Context, *SimpleRequest) (*SimpleResponse, error)
	StreamingOutputCall(context.Context, *StreamingOutputCallRequest, TestService_StreamingOutputCallServer) error
	StreamingInputCall(context.Context, TestService_StreamingInputCallServer) (*StreamingInputCallResponse, error)
	FullDuplexCall(context.Context, TestService_FullDuplexCallServer) error
	HalfDuplexCall(context.Context, TestService_HalfDuplexCallServer) error
}

type TestService_StreamingOutputCallServer interface {
	Send(*StreamingOutputCallResponse) error
	ttrpc.StreamServer
}

type testserviceStreamingOutputCallServer struct {
	ttrpc.StreamServer
}

func (x *testserviceStreamingOutputCallServer) Send(m *StreamingOutputCallResponse) error {
	return x.StreamServer.SendMsg(m)
}

type TestService_StreamingInputCallServer interface {
	Recv() (*StreamingInputCallRequest, error)
	ttrpc.StreamServer
}

type testserviceStreamingInputCallServer struct {
	ttrpc.StreamServer
}

func (x *testserviceStreamingInputCallServer) Recv() (*StreamingInputCallRequest, error) {
	m := new(StreamingInputCallRequest)
	if err := x.StreamServer.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

type TestService_FullDuplexCallServer interface {
	Send(*StreamingOutputCallResponse) error
	Recv() (*StreamingOutputCallRequest, error)
	ttrpc.StreamServer
}

type testserviceFullDuplexCallServer struct {
	ttrpc.StreamServer
}

func (x *testserviceFullDuplexCallServer) Send(m *StreamingOutputCallResponse) error {
	return x.StreamServer.SendMsg(m)
}

func (x *testserviceFullDuplexCallServer) Recv() (*StreamingOutputCallRequest, error) {
	m := new(StreamingOutputCallRequest)
	if err := x.StreamServer.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

type TestService_HalfDuplexCallServer interface {
	Send(*StreamingOutputCallResponse) error
	Recv() (*StreamingOutputCallRequest, error)
	ttrpc.StreamServer
}

type testserviceHalfDuplexCallServer struct {
	ttrpc.StreamServer
}

func (x *testserviceHalfDuplexCallServer) Send(m *StreamingOutputCallResponse) error {
	return x.StreamServer.SendMsg(m)
}

func (x *testserviceHalfDuplexCallServer) Recv() (*StreamingOutputCallRequest, error) {
	m := new(StreamingOutputCallRequest)
	if err := x.StreamServer.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func RegisterTestServiceService(srv *ttrpc.Server, svc TestServiceService) {
	srv.RegisterService("TestService", &ttrpc.ServiceDesc{
		Methods: map[string]ttrpc.Method{
			"EmptyCall": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
				var req Empty
				if err := unmarshal(&req); err != nil {
					return nil, err
				}
				return svc.EmptyCall(ctx, &req)
			},
			"UnaryCall": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
				var req SimpleRequest
				if err := unmarshal(&req); err != nil {
					return nil, err
				}
				return svc.UnaryCall(ctx, &req)
			},
		},
		Streams: map[string]ttrpc.Stream{
			"StreamingOutputCall": {
				Handler: func(ctx context.Context, stream ttrpc.StreamServer) (interface{}, error) {
					m := new(StreamingOutputCallRequest)
					if err := stream.RecvMsg(m); err != nil {
						return nil, err
					}
					return nil, svc.StreamingOutputCall(ctx, m, &testserviceStreamingOutputCallServer{stream})
				},
				StreamingClient: false,
				StreamingServer: true,
			},
			"StreamingInputCall": {
				Handler: func(ctx context.Context, stream ttrpc.StreamServer) (interface{}, error) {
					return svc.StreamingInputCall(ctx, &testserviceStreamingInputCallServer{stream})
				},
				StreamingClient: true,
				StreamingServer: false,
			},
			"FullDuplexCall": {
				Handler: func(ctx context.Context, stream ttrpc.StreamServer) (interface{}, error) {
					return nil, svc.FullDuplexCall(ctx, &testserviceFullDuplexCallServer{stream})
				},
				StreamingClient: true,
				StreamingServer: true,
			},
			"HalfDuplexCall": {
				Handler: func(ctx context.Context, stream ttrpc.StreamServer) (interface{}, error) {
					return nil, svc.HalfDuplexCall(ctx, &testserviceHalfDuplexCallServer{stream})
				},
				StreamingClient: true,
				StreamingServer: true,
			},
		},
	})
}

type TestServiceClient interface {
	EmptyCall(context.Context, *Empty) (*Empty, error)
	UnaryCall(context.Context, *SimpleRequest) (*SimpleResponse, error)
	StreamingOutputCall(context.Context, *StreamingOutputCallRequest) (TestService_StreamingOutputCallClient, error)
	StreamingInputCall(context.Context) (TestService_StreamingInputCallClient, error)
	FullDuplexCall(context.Context) (TestService_FullDuplexCallClient, error)
	HalfDuplexCall(context.Context) (TestService_HalfDuplexCallClient, error)
}

type testserviceClient struct {
	client *ttrpc.Client
}

func NewTestServiceClient(client *ttrpc.Client) TestServiceClient {
	return &testserviceClient{
		client: client,
	}
}

func (c *testserviceClient) EmptyCall(ctx context.Context, req *Empty) (*Empty, error) {
	var resp Empty
	if err := c.client.Call(ctx, "TestService", "EmptyCall", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *testserviceClient) UnaryCall(ctx context.Context, req *SimpleRequest) (*SimpleResponse, error) {
	var resp SimpleResponse
	if err := c.client.Call(ctx, "TestService", "UnaryCall", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *testserviceClient) StreamingOutputCall(ctx context.Context, req *StreamingOutputCallRequest) (TestService_StreamingOutputCallClient, error) {
	stream, err := c.client.NewStream(ctx, &ttrpc.StreamDesc{
		StreamingClient: false,
		StreamingServer: true,
	}, "TestService", "StreamingOutputCall", req)
	if err != nil {
		return nil, err
	}
	x := &testserviceStreamingOutputCallClient{stream}
	return x, nil
}

type TestService_StreamingOutputCallClient interface {
	Recv() (*StreamingOutputCallResponse, error)
	ttrpc.ClientStream
}

type testserviceStreamingOutputCallClient struct {
	ttrpc.ClientStream
}

func (x *testserviceStreamingOutputCallClient) Recv() (*StreamingOutputCallResponse, error) {
	m := new(StreamingOutputCallResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *testserviceClient) StreamingInputCall(ctx context.Context) (TestService_StreamingInputCallClient, error) {
	stream, err := c.client.NewStream(ctx, &ttrpc.StreamDesc{
		StreamingClient: true,
		StreamingServer: false,
	}, "TestService", "StreamingInputCall", nil)
	if err != nil {
		return nil, err
	}
	x := &testserviceStreamingInputCallClient{stream}
	return x, nil
}

type TestService_StreamingInputCallClient interface {
	Send(*StreamingInputCallRequest) error
	CloseAndRecv() (*StreamingInputCallResponse, error)
	ttrpc.ClientStream
}

type testserviceStreamingInputCallClient struct {
	ttrpc.ClientStream
}

func (x *testserviceStreamingInputCallClient) Send(m *StreamingInputCallRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *testserviceStreamingInputCallClient) CloseAndRecv() (*StreamingInputCallResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(StreamingInputCallResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *testserviceClient) FullDuplexCall(ctx context.Context) (TestService_FullDuplexCallClient, error) {
	stream, err := c.client.NewStream(ctx, &ttrpc.StreamDesc{
		StreamingClient: true,
		StreamingServer: true,
	}, "TestService", "FullDuplexCall", nil)
	if err != nil {
		return nil, err
	}
	x := &testserviceFullDuplexCallClient{stream}
	return x, nil
}

type TestService_FullDuplexCallClient interface {
	Send(*StreamingOutputCallRequest) error
	Recv() (*StreamingOutputCallResponse, error)
	ttrpc.ClientStream
}

type testserviceFullDuplexCallClient struct {
	ttrpc.ClientStream
}

func (x *testserviceFullDuplexCallClient) Send(m *StreamingOutputCallRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *testserviceFullDuplexCallClient) Recv() (*StreamingOutputCallResponse, error) {
	m := new(StreamingOutputCallResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *testserviceClient) HalfDuplexCall(ctx context.Context) (TestService_HalfDuplexCallClient, error) {
	stream, err := c.client.NewStream(ctx, &ttrpc.StreamDesc{
		StreamingClient: true,
		StreamingServer: true,
	}, "TestService", "HalfDuplexCall", nil)
	if err != nil {
		return nil, err
	}
	x := &testserviceHalfDuplexCallClient{stream}
	return x, nil
}

type TestService_HalfDuplexCallClient interface {
	Send(*StreamingOutputCallRequest) error
	Recv() (*StreamingOutputCallResponse, error)
	ttrpc.ClientStream
}

type testserviceHalfDuplexCallClient struct {
	ttrpc.ClientStream
}

func (x *testserviceHalfDuplexCallClient) Send(m *StreamingOutputCallRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *testserviceHalfDuplexCallClient) Recv() (*StreamingOutputCallResponse, error) {
	m := new(StreamingOutputCallResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

type UnimplementedServiceService interface {
	UnimplementedCall(context.Context, *Empty) (*Empty, error)
}

func RegisterUnimplementedServiceService(srv *ttrpc.Server, svc UnimplementedServiceService) {
	srv.RegisterService("UnimplementedService", &ttrpc.ServiceDesc{
		Methods: map[string]ttrpc.Method{
			"UnimplementedCall": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
				var req Empty
				if err := unmarshal(&req); err != nil {
					return nil, err
				}
				return svc.UnimplementedCall(ctx, &req)
			},
		},
	})
}

type unimplementedserviceClient struct {
	client *ttrpc.Client
}

func NewUnimplementedServiceClient(client *ttrpc.Client) UnimplementedServiceService {
	return &unimplementedserviceClient{
		client: client,
	}
}

func (c *unimplementedserviceClient) UnimplementedCall(ctx context.Context, req *Empty) (*Empty, error) {
	var resp Empty
	if err := c.client.Call(ctx, "UnimplementedService", "UnimplementedCall", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}
